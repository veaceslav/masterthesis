% Chapter Template

\chapter{SWAN Data Specifications}\label{ssec:swandataspecifications} % Main chapter title

\label{Chapter4} % Change X to a consecutive number; for referencing this chapter elsewhere, use \ref{ChapterX}

\lhead{Chapter 4. \emph{SWAN Data Specifications}} % Change X to a consecutive number; this is for the header on each page - perhaps a shortened title

%----------------------------------------------------------------------------------------
%	SECTION 1
%----------------------------------------------------------------------------------------

\section{Introduction}
Initially SWAN was designed to take a single value from the sensor data.
The value should be a primitive type such as Integer, Float, Double etc.
This constraint applies because SWAN evaluation engine allows the programmer to perform MIN, MAX and AVERAGE operations on given sensor data.
Also, History reduction is important when using the single value.

By adding multiple sensors, it became clear that taking a single value is not scalable enough. 
The further changes were delayed by adding multiple value paths to the sensor implementation. 
A clear example was accelerometer data: You will probably need the values for all 3 axes: x, y, z.
And you need to register 3 expressions for each value path.
The limitation can no longer be avoided after implementing Beacon Sensors, because now we need to add a full array of beacon identifiers under the same timestamp,
the key-value to provide individual temperature data or even key-array of values if we want the accelerometer data from all beacons.

%-----------------------------------
%	SUBSECTION 1
%-----------------------------------
\section{Proposed Solutions}
All the proposed solutions should meet the following requirements:
\begin{itemize}
 \item Support multiple sensors of the same type (beacon sensor)
 \item Support multiple values for each sensor
 \item Provide scheme for single sensor single value data
 \item Provide implementation for Evaluation Engine Application
\end{itemize}

\subsection{Data Mapping approach}
Data Mapping tries to solve the problem by proposing a new, novel approach of how data is being passed form the sensor
to the evaluation engine. The model is aiming to solve future problems when it comes to supporting multiple sensors
with multiple values at the same time. The drawback of this solution is the number of changes that are required to be done in
Evaluation Engine and sensors, in order to implement the new approach. Also there is a high risk of breaking compatibility
with older expressions.

The format of data for the following function calls(value parameter):
\begin{lstlisting}[language=Java]
 AbstractSwanSensor.putValueTrimSize(final String valuePath,
					final String id,
					final long now,
					final Object value):
\end{lstlisting}

In order to satisfy the new requirements, we propose the new data format to be encoded as: \begin{verbatim} Map<ValuePath, Map<sensorID,  ArrayList<Object>> \end{verbatim}

where:
\begin{itemize}
 \item ValuePath  = sensor valuepaths, ex Acceleromter x, y, z, total
 \item sensorID  =  self or unique Sensor Identifier(BeaconID)
\end{itemize}

We identify four sensor formats and recommend the following representation for each type of sensor:
\begin{itemize}
  \item Single Sensor Single Value(sensor name = stepcounter):
  \begin{itemize}
    \item \begin{verbatim} Example: Map: { steps={self=[13434545 ] }} \end{verbatim}                                                              
  \end{itemize}
 
  \item  Single Sensor, Multiple Values(sensor name =accelerometer):
  \begin{itemize}
    \item Key - name of the sensor
    \item Array of values - multiple values in the same order
    \item \begin{verbatim} Example: Map: { x={self=[0.5]},
                 y={self=[0.6]}, z={self=[-0.5]} } \end{verbatim}  
  \end{itemize}

 
  \item Multiple Sensor, Single Value(Beacon Distance):
  \begin{itemize}
    \item Key - the sensor identifier(id)
    \item Array of values - single value in the array
    \item  \begin{verbatim}  Example: Map: {distance={beaconID1=[1.5],
                 beaconID2=[0.5], beaconID3=[0.2]}} \end{verbatim}  
  \end{itemize}

  \item  Multiple Sensor, Multiple Values(sensor name = Beacon Accelerometer):
  \begin{itemize}
    \item Key - the sensor identifier(id), should be unique
    \item Array of values - multiple values in the same order
    \item  \begin{verbatim}  Example: Map:{x ={beaconID1=[-0.5], beaconID2=[-0.1],
                y = {beaconID1=[ 0.2], beaconID2=[-0.4]}} \end{verbatim}  
 \end{itemize}


\end{itemize}




%-----------------------------------
%	SUBSECTION 2
%-----------------------------------

\subsection{Expression Location Approach} \label{sssec:exprlocation}
Compared to the Data Mapping, Expression Location Approach tries to preserve the single return value and value paths for each sensor.
It works in addition to the current implementation and maintain the backwards compatibility with the previous expression format.
The drawback of this approach is very low flexibility when the number of sensors are really high. Also , it tries to solve an immediate 
problem rather than focusing on future challenges.

Instead of using a map to send the values to the evaluation engine, we add an extension to the current location of the swan expression.
The evaluation engine recognize keywords such as \textbf{self}, \textbf{wear} and \textbf{remote}. To support the multiple sensors, 
we add the sensor's unique identifier instead of the location. In case of Beacons, each beacon has beacon Id, which should be unique for 
all kind of applications.

The recommended swan expressions for the 4 categories of sensors:

\begin{itemize}
  \item Single Sensor Single Value(sensor name = stepcounter):
  \begin{itemize}
    \item Register an expression: \begin{verbatim}  self@stepcounter:steps{ANY, 1000}\end{verbatim} 
    \item Use putTrimValue() with a single value
  \end{itemize}
 
  \item  Single Sensor, Multiple Values(sensor name =accelerometer):
  \begin{itemize}
    \item Register an expression with value path: \begin{verbatim} self@accelerometer:x{ANY, 1000}\end{verbatim}
    \item Use putTrimValue() with a single value
  \end{itemize}

  \item Multiple Sensor, Single Value(Beacon Distance):
  \begin{itemize}
    \item Use Beacon Discovery Sensor to get a list beaconIDs: \begin{verbatim} self@beacon_discovery:ibeaconuuid{ANY, 10}\end{verbatim} 
  \end{itemize}

  \item  Multiple Sensor, Multiple Values(sensor name = Beacon Accelerometer):
  \begin{itemize}
    \item Use Beacon Discovery Sensor to get a list beaconIDs: \begin{verbatim} self@beacon_discovery:ibeaconuuid{ANY, 10}\end{verbatim}
    \item Register individual expressions with individual valuepaths for each BeaconID: 
    \begin{itemize}
     \item \begin{verbatim} beaconID@beacon_movement:x{ANY,1000} \end{verbatim}
     \item \begin{verbatim} beaconID@beacon_movement:y{ANY,1000} \end{verbatim}
    \end{itemize}

 \end{itemize}


\end{itemize}

Note these expressions can not be evaluated by Evaluation Engine, because it outputs an array instead of a single value.

%----------------------------------------------------------------------------------------
%	SECTION 2
%----------------------------------------------------------------------------------------

\section{Implemented Approach}
The implemented solution was the \hyperref[sssec:exprlocation]{Expression Location Approach}.
The while the Data Mapping approach brings more novelty, it comes with severe disadvantages:
\begin{itemize}
 \item Unable to keep backward compatibility with older applications which are using SWAN - before the changes, applications
 expect a single primitive value. Using an array or a map may result in application crashes.
 \item While the Value Based Expressions are easy to adapt, changing Tristate Expressions is more difficult - Evaluation engine needs to be redesigned to adapt the new approach
 \item Big number of changes may render SWAN unstable and it will take a long time to narrow down bugs
\end{itemize}

On the other hand, the Location Based does not interfere with Evaluation Engine's algorithm, and location can be easily passed to the sensor implementation and 
handled by sensor implementations. 

Implementing the location extension was easy, we just added an extra parameter of type \textbf{Map} which we pass to the sensor
when we bind it.
The existing sensors preserved their implementation without changes and the beacon based sensors were adapted to get the beacon ID from the location parameters.
Also, for Bluetooth sensor discovery purpose, we left the Discovery sensor to output an array instead of a single value, assuming that no Tri-State Expression will be registered with that 
sensor.
